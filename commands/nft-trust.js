/**
 * Copyright (c) 2024-2025 JME (jmenichole)
 * All Rights Reserved
 * 
 * PROPRIETARY AND CONFIDENTIAL
 * Unauthorized copying of this file, via any medium, is strictly prohibited.
 * 
 * This file is part of TiltCheck/TrapHouse Discord Bot ecosystem.
 * For licensing information, see LICENSE file in the root directory.
 */

/**
 * NFT-Based User Trust Discord Commands
 * /trust - NFT contract-based trust scoring with scam reporting
 */

const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const NFTUserTrustSystem = require('../nftUserTrustSystem');
const BetaVerificationContract = require('../beta-verification-contract');

const trustSystem = new NFTUserTrustSystem();
const nftContract = new BetaVerificationContract();

module.exports = {
    data: new SlashCommandBuilder()
        .setName('trust')
        .setDescription('NFT contract-based trust scoring system')
        .addSubcommand(subcommand =>
            subcommand
                .setName('init')
                .setDescription('Initialize trust score with NFT contract'))
        .addSubcommand(subcommand =>
            subcommand
                .setName('score')
                .setDescription('View trust score')
                .addUserOption(option =>
                    option.setName('user')
                        .setDescription('User to check (leave empty for yourself)')
                        .setRequired(false)))
        .addSubcommand(subcommand =>
            subcommand
                .setName('verify-link')
                .setDescription('Add verified link to increase trust')
                .addStringOption(option =>
                    option.setName('type')
                        .setDescription('Type of link')
                        .setRequired(true)
                        .addChoices(
                            { name: 'Wallet', value: 'wallet' },
                            { name: 'Casino Account', value: 'casino' },
                            { name: 'Social Media', value: 'social' }
                        ))
                .addStringOption(option =>
                    option.setName('link')
                        .setDescription('Link or address to verify')
                        .setRequired(true)))
        .addSubcommand(subcommand =>
            subcommand
                .setName('degen-proof')
                .setDescription('Record degen proof action')
                .addStringOption(option =>
                    option.setName('type')
                        .setDescription('Type of proof')
                        .setRequired(true)
                        .addChoices(
                            { name: 'Loss Transparency', value: 'loss_transparency' },
                            { name: 'Tilt Recovery', value: 'tilt_recovery' },
                            { name: 'Limit Adherence', value: 'limit_adherence' },
                            { name: 'Profit Withdrawal', value: 'profit_withdrawal' },
                            { name: 'Community Help', value: 'community_help' }
                        ))
                .addStringOption(option =>
                    option.setName('description')
                        .setDescription('Describe your proof action')
                        .setRequired(true))
                .addStringOption(option =>
                    option.setName('evidence')
                        .setDescription('Evidence links (optional)')
                        .setRequired(false)))
        .addSubcommand(subcommand =>
            subcommand
                .setName('report-scam')
                .setDescription('Report verified scam event')
                .addUserOption(option =>
                    option.setName('target')
                        .setDescription('User to report')
                        .setRequired(true))
                .addStringOption(option =>
                    option.setName('type')
                        .setDescription('Type of scam')
                        .setRequired(true)
                        .addChoices(
                            { name: 'Fake Giveaway', value: 'fake_giveaway' },
                            { name: 'Phishing Link', value: 'phishing' },
                            { name: 'Payment Fraud', value: 'payment_fraud' },
                            { name: 'Impersonation', value: 'impersonation' },
                            { name: 'Other', value: 'other' }
                        ))
                .addStringOption(option =>
                    option.setName('evidence')
                        .setDescription('Evidence of scam')
                        .setRequired(true))
                .addStringOption(option =>
                    option.setName('description')
                        .setDescription('Detailed description')
                        .setRequired(true)))
        .addSubcommand(subcommand =>
            subcommand
                .setName('summary')
                .setDescription('View complete trust summary')
                .addUserOption(option =>
                    option.setName('user')
                        .setDescription('User to check (leave empty for yourself)')
                        .setRequired(false))),

    async execute(interaction) {
        const subcommand = interaction.options.getSubcommand();
        
        try {
            switch (subcommand) {
                case 'init':
                    await this.handleInitCommand(interaction);
                    break;
                case 'score':
                    await this.handleScoreCommand(interaction);
                    break;
                case 'verify-link':
                    await this.handleVerifyLinkCommand(interaction);
                    break;
                case 'degen-proof':
                    await this.handleDegenProofCommand(interaction);
                    break;
                case 'report-scam':
                    await this.handleReportScamCommand(interaction);
                    break;
                case 'summary':
                    await this.handleSummaryCommand(interaction);
                    break;
            }
        } catch (error) {
            console.error('Trust command error:', error);
            await interaction.reply({
                content: '‚ùå An error occurred processing your request.',
                ephemeral: true
            });
        }
    },

    async handleInitCommand(interaction) {
        const userId = interaction.user.id;
        
        await interaction.deferReply({ ephemeral: true });

        try {
            // Check if user has NFT contract
            const hasContract = await nftContract.hasValidContract(userId);
            
            if (!hasContract) {
                const embed = new EmbedBuilder()
                    .setTitle('‚ùå NFT Contract Required')
                    .setColor(0xff0000)
                    .setDescription('**You need to sign an NFT contract first.**')
                    .addFields(
                        { name: 'üìã Requirements', value: 'Valid NFT contract signature required to begin trust scoring' },
                        { name: 'üîß Next Steps', value: 'Complete the NFT contract verification process first' }
                    );

                await interaction.editReply({ embeds: [embed] });
                return;
            }

            // Get NFT info
            const nftInfo = await nftContract.verifyNFTOwnership(userId);
            const tokenId = nftInfo.nfts[0]?.tokenId || 'unknown';

            // Initialize trust score
            const result = await trustSystem.initializeTrustScore(userId, tokenId);

            if (result.success) {
                const embed = new EmbedBuilder()
                    .setTitle('‚úÖ Trust Score Initialized!')
                    .setColor(0x00ff00)
                    .setDescription('**Your NFT contract-based trust scoring is now active.**')
                    .addFields(
                        { name: 'üé´ NFT Token ID', value: tokenId, inline: true },
                        { name: 'üìä Starting Score', value: `${result.trustScore}/1000`, inline: true },
                        { name: 'üèÜ Trust Tier', value: 'NEW_USER', inline: true },
                        { name: 'üéØ Next Steps', value: '‚Ä¢ Verify wallet links (+50 points)\n‚Ä¢ Record degen proof actions (+45 points)\n‚Ä¢ Help community members (+35 points)' },
                        { name: 'üö® Scam Reporting', value: 'Report verified scam events once you reach 200+ trust score' }
                    );

                await interaction.editReply({ embeds: [embed] });
            } else {
                const embed = new EmbedBuilder()
                    .setTitle('‚ùå Initialization Failed')
                    .setColor(0xff0000)
                    .setDescription(result.message);

                await interaction.editReply({ embeds: [embed] });
            }
        } catch (error) {
            console.error('Init command error:', error);
            await interaction.editReply({
                content: '‚ùå Failed to initialize trust score.'
            });
        }
    },

    async handleScoreCommand(interaction) {
        const targetUser = interaction.options.getUser('user') || interaction.user;
        const targetUserId = targetUser.id;

        await interaction.deferReply({ ephemeral: false });

        const trustScore = await trustSystem.calculateUserTrustScore(targetUserId);

        const embed = new EmbedBuilder()
            .setTitle(`üîí Trust Score - ${targetUser.displayName}`)
            .setColor(this.getTrustColor(trustScore.totalScore))
            .setThumbnail(targetUser.displayAvatarURL());

        if (trustScore.totalScore === 0) {
            embed.setDescription('‚ùå **No Trust Score Found**\n\nSign an NFT contract to begin trust scoring.')
                .addFields(
                    { name: 'üìã Getting Started', value: 'Use `/trust init` to initialize your trust score with NFT contract verification.' },
                    { name: 'üéØ Trust Benefits', value: '‚Ä¢ Verified link rewards\n‚Ä¢ Degen proof recognition\n‚Ä¢ Scam reporting abilities\n‚Ä¢ Community trust building' }
                );
        } else {
            const progressBar = this.createProgressBar(trustScore.totalScore, 1000);
            const breakdown = trustScore.breakdown;

            embed.setDescription(`**Trust Tier:** ${trustScore.trustTier}\n**Status:** ${trustScore.status.toUpperCase()}\n\n${progressBar}`)
                .addFields(
                    { name: 'üìä Total Score', value: `**${trustScore.totalScore}**/1000`, inline: true },
                    { name: 'üèÜ Trust Tier', value: trustScore.trustTier, inline: true },
                    { name: 'üö® Sus Score', value: `${trustScore.susScore}/1000`, inline: true },
                    { name: 'üé´ NFT Contract', value: `${breakdown.nftContract} points`, inline: true },
                    { name: 'üîó Verified Links', value: `${breakdown.verifiedLinks} points`, inline: true },
                    { name: 'üéØ Degen Proof', value: `${breakdown.degenProofActions} points`, inline: true },
                    { name: 'üö® Scam Reports', value: `${breakdown.scamReporting} points`, inline: true },
                    { name: 'üìà Growth Tips', value: this.getTrustGrowthTips(trustScore.totalScore), inline: false }
                );
        }

        // Action buttons
        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('trust_verify_link')
                    .setLabel('Verify Link')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('üîó'),
                new ButtonBuilder()
                    .setCustomId('trust_degen_proof')
                    .setLabel('Degen Proof')
                    .setStyle(ButtonStyle.Success)
                    .setEmoji('üéØ'),
                new ButtonBuilder()
                    .setCustomId('trust_summary')
                    .setLabel('Full Summary')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìä')
            );

        await interaction.editReply({
            embeds: [embed],
            components: [actionRow]
        });
    },

    async handleVerifyLinkCommand(interaction) {
        const userId = interaction.user.id;
        const linkType = interaction.options.getString('type');
        const linkData = interaction.options.getString('link');

        await interaction.deferReply({ ephemeral: true });

        const result = await trustSystem.addVerifiedLink(userId, linkType, linkData);

        if (result.success) {
            const embed = new EmbedBuilder()
                .setTitle('‚úÖ Verified Link Added!')
                .setColor(0x00ff00)
                .setDescription('**Your verified link has been added successfully.**')
                .addFields(
                    { name: 'üîó Link Type', value: this.formatLinkType(linkType), inline: true },
                    { name: '‚≠ê Points Earned', value: `+${result.trustPointsAwarded}`, inline: true },
                    { name: 'üìä New Total', value: `${result.newTotalScore}/1000`, inline: true },
                    { name: 'üí° Next Steps', value: 'Continue adding verified links and recording degen proof actions to grow your trust score!' }
                );

            await interaction.editReply({ embeds: [embed] });
        } else {
            const embed = new EmbedBuilder()
                .setTitle('‚ùå Link Verification Failed')
                .setColor(0xff0000)
                .setDescription(result.message)
                .addFields(
                    { name: 'üìã Requirements', value: 'NFT contract must be signed before adding verified links' }
                );

            await interaction.editReply({ embeds: [embed] });
        }
    },

    async handleDegenProofCommand(interaction) {
        const userId = interaction.user.id;
        const proofType = interaction.options.getString('type');
        const description = interaction.options.getString('description');
        const evidence = interaction.options.getString('evidence') || '';

        await interaction.deferReply({ ephemeral: true });

        const result = await trustSystem.recordDegenProofAction(userId, proofType, description, evidence);

        if (result.success) {
            const embed = new EmbedBuilder()
                .setTitle('üéØ Degen Proof Recorded!')
                .setColor(0x00ff00)
                .setDescription('**Your degen proof action has been verified and recorded.**')
                .addFields(
                    { name: 'üé≠ Proof Type', value: this.formatProofType(proofType), inline: true },
                    { name: '‚≠ê Points Earned', value: `+${result.trustPointsAwarded}`, inline: true },
                    { name: 'üéÅ Bonus', value: result.consistencyBonus > 0 ? `+${result.consistencyBonus}` : 'None', inline: true },
                    { name: 'üìä New Total', value: `${result.newTotalScore}/1000`, inline: false },
                    { name: 'üìù Description', value: description, inline: false }
                );

            if (result.consistencyBonus > 0) {
                embed.addFields({ name: 'üî• Consistency Bonus!', value: 'You earned bonus points for multiple degen proof actions!' });
            }

            await interaction.editReply({ embeds: [embed] });
        } else {
            const embed = new EmbedBuilder()
                .setTitle('‚ùå Degen Proof Failed')
                .setColor(0xff0000)
                .setDescription(result.message)
                .addFields(
                    { name: 'üìã Requirements', value: 'NFT contract must be signed before recording degen proof actions' }
                );

            await interaction.editReply({ embeds: [embed] });
        }
    },

    async handleReportScamCommand(interaction) {
        const reporterId = interaction.user.id;
        const targetUser = interaction.options.getUser('target');
        const scamType = interaction.options.getString('type');
        const evidence = interaction.options.getString('evidence');
        const description = interaction.options.getString('description');

        await interaction.deferReply({ ephemeral: true });

        const result = await trustSystem.reportScamEvent(reporterId, targetUser.id, scamType, evidence, description);

        if (result.success) {
            const embed = new EmbedBuilder()
                .setTitle('üö® Scam Report Submitted')
                .setColor(0xff6600)
                .setDescription('**Your scam report has been submitted for review.**')
                .addFields(
                    { name: 'üë§ Reported User', value: targetUser.displayName, inline: true },
                    { name: 'üö® Scam Type', value: this.formatScamType(scamType), inline: true },
                    { name: 'üìã Report ID', value: result.reportId, inline: true },
                    { name: '‚≠ê Trust Points', value: `+${result.trustPointsAwarded}`, inline: true },
                    { name: '‚è±Ô∏è Status', value: 'Under Review', inline: true },
                    { name: 'üìù Description', value: description.length > 100 ? description.substring(0, 100) + '...' : description, inline: false },
                    { name: '‚ö†Ô∏è Important', value: 'False reports may result in trust score penalties. Only report verified scams with solid evidence.' }
                );

            await interaction.editReply({ embeds: [embed] });
        } else {
            const embed = new EmbedBuilder()
                .setTitle('‚ùå Scam Report Failed')
                .setColor(0xff0000)
                .setDescription(result.message)
                .addFields(
                    { name: 'üìã Requirements', value: '‚Ä¢ NFT contract signed\n‚Ä¢ Trust score ‚â• 200\n‚Ä¢ Valid evidence provided' }
                );

            await interaction.editReply({ embeds: [embed] });
        }
    },

    async handleSummaryCommand(interaction) {
        const targetUser = interaction.options.getUser('user') || interaction.user;
        const targetUserId = targetUser.id;

        await interaction.deferReply({ ephemeral: false });

        const summary = await trustSystem.getUserTrustSummary(targetUserId);

        if (summary.error) {
            const embed = new EmbedBuilder()
                .setTitle('‚ùå Trust Summary Error')
                .setColor(0xff0000)
                .setDescription(summary.error)
                .addFields(
                    { name: 'üìã Requirements', value: 'NFT contract must be signed to access trust system.' }
                );

            await interaction.editReply({ embeds: [embed] });
            return;
        }

        const userTrust = summary.userTrust;
        const riskEmoji = this.getRiskEmoji(summary.riskLevel);

        const embed = new EmbedBuilder()
            .setTitle(`${riskEmoji} Trust Summary - ${targetUser.displayName}`)
            .setColor(this.getTrustColor(userTrust.totalScore))
            .setThumbnail(targetUser.displayAvatarURL())
            .setDescription(`**Trust Tier:** ${userTrust.trustTier}\n**Risk Level:** ${summary.riskLevel}`)
            .addFields(
                { name: 'üë§ User Trust Score', value: `**${userTrust.totalScore}**/1000\n${this.createProgressBar(userTrust.totalScore, 1000)}`, inline: false },
                { name: 'üö® Sus Score', value: `**${summary.susScore}**/1000`, inline: true },
                { name: '‚ö†Ô∏è Risk Level', value: summary.riskLevel.replace('_', ' '), inline: true },
                { name: 'üé´ NFT Required', value: summary.nftContractRequired ? 'Yes' : 'No', inline: true }
            );

        // Trust breakdown
        if (userTrust.breakdown) {
            const breakdown = userTrust.breakdown;
            embed.addFields({
                name: 'üìä Trust Score Breakdown',
                value: `üé´ NFT Contract: ${breakdown.nftContract}\nüîó Verified Links: ${breakdown.verifiedLinks}\nüéØ Degen Proof: ${breakdown.degenProofActions}\nüö® Scam Reports: ${breakdown.scamReporting}`,
                inline: false
            });
        }

        // Recommendations
        embed.addFields({
            name: 'üí° Recommendations',
            value: this.getRecommendations(userTrust.totalScore, summary.susScore),
            inline: false
        });

        embed.setFooter({ text: `Last calculated: ${new Date(summary.calculatedAt).toLocaleString()}` });

        await interaction.editReply({ embeds: [embed] });
    },

    // Utility methods
    getTrustColor(score) {
        if (score >= 1000) return 0xFFD700; // Gold
        if (score >= 750) return 0x00FF00;  // Green
        if (score >= 500) return 0x32CD32;  // Lime
        if (score >= 250) return 0xFFFF00;  // Yellow
        if (score >= 100) return 0xFFA500;  // Orange
        return 0xFF0000; // Red
    },

    createProgressBar(current, max, length = 20) {
        const percentage = Math.min(current / max, 1);
        const filled = Math.round(percentage * length);
        const empty = length - filled;
        return `\`${'‚ñà'.repeat(filled)}${'‚ñë'.repeat(empty)}\` ${Math.round(percentage * 100)}%`;
    },

    getRiskEmoji(riskLevel) {
        const emojis = {
            'CRITICAL': 'üö®',
            'HIGH_RISK': '‚ö†Ô∏è',
            'MODERATE_HIGH': 'üü°',
            'MODERATE_RISK': 'üü°',
            'LOW_RISK': 'üü¢',
            'MINIMAL_RISK': '‚úÖ'
        };
        return emojis[riskLevel] || '‚ùì';
    },

    formatLinkType(type) {
        const types = {
            'wallet': 'üîó Wallet Address',
            'casino': 'üé∞ Casino Account',
            'social': 'üì± Social Media'
        };
        return types[type] || type;
    },

    formatProofType(type) {
        const types = {
            'loss_transparency': 'üìâ Loss Transparency',
            'tilt_recovery': 'üîÑ Tilt Recovery',
            'limit_adherence': 'üéØ Limit Adherence',
            'profit_withdrawal': 'üí∞ Profit Withdrawal',
            'community_help': 'üë• Community Help'
        };
        return types[type] || type;
    },

    formatScamType(type) {
        const types = {
            'fake_giveaway': 'üéÅ Fake Giveaway',
            'phishing': 'üé£ Phishing Link',
            'payment_fraud': 'üí≥ Payment Fraud',
            'impersonation': 'üé≠ Impersonation',
            'other': '‚ö†Ô∏è Other Scam'
        };
        return types[type] || type;
    },

    getTrustGrowthTips(score) {
        if (score < 200) {
            return 'üéØ Add verified links (+50 each)\nüìù Record degen proof actions (+45 each)';
        } else if (score < 500) {
            return 'üö® Report verified scams (+60 each)\nüë• Help community members (+35 each)';
        } else {
            return 'üèÜ Mentor new users\nüîÑ Maintain consistency for bonus points';
        }
    },

    getRecommendations(trustScore, susScore) {
        let recommendations = [];

        if (trustScore < 200) {
            recommendations.push('üé´ Complete NFT contract verification');
            recommendations.push('üîó Add verified wallet links');
        }

        if (trustScore < 500) {
            recommendations.push('üéØ Record degen proof actions');
            recommendations.push('üë• Engage with community');
        }

        if (susScore > 100) {
            recommendations.push('‚ö†Ô∏è Address suspicious activity');
            recommendations.push('ü§ù Improve community interactions');
        }

        if (trustScore >= 500) {
            recommendations.push('üèÜ Mentor new users');
            recommendations.push('üö® Help verify scam reports');
        }

        return recommendations.length > 0 ? recommendations.join('\n') : '‚úÖ Excellent trust profile!';
    }
};
